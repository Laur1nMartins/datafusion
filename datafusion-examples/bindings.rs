/* automatically generated by rust-bindgen 0.71.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const OWN_LAST_INFLATE_MANIPULATOR: u32 = 8;
pub const OWN_RESERVED_INFLATE_MANIPULATOR: u32 = 7;
pub const DICT_NONE: i32 = -1;
pub const QPL_FLAG_FIRST: u32 = 1;
pub const QPL_FLAG_LAST: u32 = 2;
pub const QPL_FLAG_CRC32C: u32 = 4;
pub const QPL_FLAG_GZIP_MODE: u32 = 8;
pub const QPL_FLAG_HUFFMAN_BE: u32 = 16;
pub const QPL_FLAG_NO_HDRS: u32 = 32;
pub const QPL_FLAG_DECOMPRESS_ENABLE: u32 = 64;
pub const QPL_FLAG_SRC2_BE: u32 = 128;
pub const QPL_FLAG_OUT_BE: u32 = 256;
pub const QPL_FLAG_RND_ACCESS: u32 = 512;
pub const QPL_FLAG_DECOMP_FLUSH_ALWAYS: u32 = 2048;
pub const QPL_FLAG_START_NEW_BLOCK: u32 = 4096;
pub const QPL_FLAG_DYNAMIC_HUFFMAN: u32 = 8192;
pub const QPL_FLAG_OMIT_VERIFY: u32 = 16384;
pub const QPL_FLAG_GEN_LITERALS: u32 = 32768;
pub const QPL_FLAG_CANNED_MODE: u32 = 4194304;
pub const QPL_FLAG_CRC64_BE: u32 = 65536;
pub const QPL_FLAG_CRC64_INV: u32 = 131072;
pub const QPL_FLAG_INV_OUT: u32 = 262144;
pub const QPL_FLAG_ZLIB_MODE: u32 = 524288;
pub const QPL_FLAG_OMIT_CHECKSUMS: u32 = 1048576;
pub const QPL_FLAG_OMIT_AGGREGATES: u32 = 2097152;
pub const QPL_FLAG_FORCE_ARRAY_OUTPUT: u32 = 8388608;
pub const QPL_DEVICE_NUMA_ID_SOCKET: i32 = -1;
pub const QPL_DEVICE_NUMA_ID_CURRENT: i32 = -2;
pub const QPL_DEVICE_NUMA_ID_ANY: i32 = -3;
pub const QPL_PROCESSING_ERROR_BASE: u32 = 0;
pub const QPL_PARAMETER_ERROR_BASE: u32 = 50;
pub const QPL_SERVICE_LOGIC_ERROR_BASE: u32 = 100;
pub const QPL_OPERATION_ERROR_BASE: u32 = 200;
pub const QPL_OPERATION_STATUS_BASE: u32 = 300;
pub const QPL_INIT_ERROR_BASE: u32 = 500;
pub const QPL_LITERALS_MATCHES_TABLE_SIZE: u32 = 286;
pub const QPL_DEFAULT_OFFSETS_NUMBER: u32 = 30;
pub const QPL_DEFAULT_LITERALS_NUMBER: u32 = 257;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"]
        [::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "< Enable auto-detection of the equipment for executing"]
pub const qpl_path_t_qpl_path_auto: qpl_path_t = 0;
#[doc = "< Enable execution by hardware path"]
pub const qpl_path_t_qpl_path_hardware: qpl_path_t = 1;
#[doc = "< Enable execution by software path (Run on CPU)"]
pub const qpl_path_t_qpl_path_software: qpl_path_t = 2;
#[doc = " @enum qpl_path_t\n @brief Enum of the executing paths"]
pub type qpl_path_t = ::std::os::raw::c_uint;
#[doc = "< Output stream in its nominal format without modification"]
pub const qpl_out_format_qpl_ow_nom: qpl_out_format = 0;
#[doc = "< Output 8-bit stream"]
pub const qpl_out_format_qpl_ow_8: qpl_out_format = 1;
#[doc = "< Output 16-bit stream"]
pub const qpl_out_format_qpl_ow_16: qpl_out_format = 2;
#[doc = "< Output 32-bit stream"]
pub const qpl_out_format_qpl_ow_32: qpl_out_format = 3;
#[doc = " @brief Enum of all output formats"]
pub type qpl_out_format = ::std::os::raw::c_uint;
#[doc = "< Input vector is written in the Little-Endian format"]
pub const qpl_parser_qpl_p_le_packed_array: qpl_parser = 0;
#[doc = "< Input vector is written in the Big-Endian format"]
pub const qpl_parser_qpl_p_be_packed_array: qpl_parser = 1;
#[doc = "< input vector is written in the Parquet RLE format"]
pub const qpl_parser_qpl_p_parquet_rle: qpl_parser = 2;
#[doc = " @brief Enum of all supported parser types"]
pub type qpl_parser = ::std::os::raw::c_uint;
#[doc = "< Performs Inflate operation (@ref DEFLATE_OPERATIONS group)"]
pub const qpl_operation_qpl_op_decompress: qpl_operation = 0;
#[doc = "< Performs Deflate operation (@ref DEFLATE_OPERATIONS group)"]
pub const qpl_operation_qpl_op_compress: qpl_operation = 1;
#[doc = "< Performs @ref CRC_OPERATION"]
pub const qpl_operation_qpl_op_crc64: qpl_operation = 5;
#[doc = "< Extract sub-vector filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_extract: qpl_operation = 17;
#[doc = "< Down-sampling filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_select: qpl_operation = 18;
#[doc = "< Up-sampling filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_expand: qpl_operation = 21;
#[doc = " Compare \"equal\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_eq: qpl_operation = 32;
#[doc = " Compare \"not-equal\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_ne: qpl_operation = 33;
#[doc = " Compare \"less\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_lt: qpl_operation = 34;
#[doc = " Compare \"less-or-equal\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_le: qpl_operation = 35;
#[doc = " Compare \"greater\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_gt: qpl_operation = 36;
#[doc = " Compare \"greater-or-equal\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_ge: qpl_operation = 37;
#[doc = " Compare \"in-range\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_range: qpl_operation = 38;
#[doc = " Compare \"not-in-range\" filter operation (@ref ANALYTIC_OPERATIONS group)"]
pub const qpl_operation_qpl_op_scan_not_range: qpl_operation = 39;
#[doc = " @brief Enum of all supported operations"]
pub type qpl_operation = ::std::os::raw::c_uint;
#[doc = "< Disable indexing for the deflate stream"]
pub const qpl_mini_block_size_qpl_mblk_size_none: qpl_mini_block_size = 0;
#[doc = "< Put index into the deflate stream each 512   bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_512: qpl_mini_block_size = 1;
#[doc = "< Put index into the deflate stream each 1024  bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_1k: qpl_mini_block_size = 2;
#[doc = "< Put index into the deflate stream each 2048  bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_2k: qpl_mini_block_size = 3;
#[doc = "< Put index into the deflate stream each 4096  bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_4k: qpl_mini_block_size = 4;
#[doc = "< Put index into the deflate stream each 8192  bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_8k: qpl_mini_block_size = 5;
#[doc = "< Put index into the deflate stream each 16384 bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_16k: qpl_mini_block_size = 6;
#[doc = "< Put index into the deflate stream each 32768 bytes"]
pub const qpl_mini_block_size_qpl_mblk_size_32k: qpl_mini_block_size = 7;
#[doc = " @brief Enumerates mini-blocks sizes for the @ref qpl_op_compress and @ref qpl_op_decompress operations."]
pub type qpl_mini_block_size = ::std::os::raw::c_uint;
#[doc = "< No compression expected to be performed on software"]
pub const sw_compression_level_SW_NONE: sw_compression_level = -1;
#[doc = "< The lowest compression level"]
pub const sw_compression_level_LEVEL_0: sw_compression_level = 0;
#[doc = "< The 1st compression level"]
pub const sw_compression_level_LEVEL_1: sw_compression_level = 1;
#[doc = "< The 2nd compression level"]
pub const sw_compression_level_LEVEL_2: sw_compression_level = 2;
#[doc = "< The 3rd compression level"]
pub const sw_compression_level_LEVEL_3: sw_compression_level = 3;
#[doc = "< The 4th compression level"]
pub const sw_compression_level_LEVEL_4: sw_compression_level = 4;
#[doc = "< The highest compression level"]
pub const sw_compression_level_LEVEL_9: sw_compression_level = 9;
#[doc = " @brief Enumerates the compression level on software path, used for building @ref qpl_dictionary"]
pub type sw_compression_level = ::std::os::raw::c_int;
#[doc = "< No compression expected to be performed on hardware"]
pub const hw_compression_level_HW_NONE: hw_compression_level = -1;
#[doc = "< The lowest compression level"]
pub const hw_compression_level_SMALL: hw_compression_level = 0;
#[doc = "< The highest compression level"]
pub const hw_compression_level_LARGE: hw_compression_level = 1;
#[doc = "< The 1st dictionary compression level, using a small-sized dictionary"]
pub const hw_compression_level_HW_LEVEL_1: hw_compression_level = 2;
#[doc = "< The 2nd dictionary compression level, using a medium-sized dictionary"]
pub const hw_compression_level_HW_LEVEL_2: hw_compression_level = 3;
#[doc = "< The 3rd dictionary compression level, using a large-sized dictionary"]
pub const hw_compression_level_HW_LEVEL_3: hw_compression_level = 4;
#[doc = " @brief Enumerates the compression level on hardware path, used for building @ref qpl_dictionary.\n A higher compression level and larger dictionary size generally result in a better compression ratio,\n but it will also result in higher latency."]
pub type hw_compression_level = ::std::os::raw::c_int;
#[doc = "< Stop condition: b_final EOB; Check condition: b_final EOB"]
pub const qpl_decomp_end_proc_qpl_stop_and_check_for_bfinal_eob: qpl_decomp_end_proc = 0;
#[doc = "< Stop condition: none;       Check condition: none"]
pub const qpl_decomp_end_proc_qpl_dont_stop_or_check: qpl_decomp_end_proc = 1;
#[doc = "< Stop condition: EOB;        Check condition: EOB"]
pub const qpl_decomp_end_proc_qpl_stop_and_check_for_any_eob: qpl_decomp_end_proc = 2;
#[doc = "< Stop condition: EOB;        Check condition: none"]
pub const qpl_decomp_end_proc_qpl_stop_on_any_eob: qpl_decomp_end_proc = 3;
#[doc = "< Stop condition: b_final EOB; Check condition: none"]
pub const qpl_decomp_end_proc_qpl_stop_on_bfinal_eob: qpl_decomp_end_proc = 4;
#[doc = "< Stop condition: none;       Check condition: EOB"]
pub const qpl_decomp_end_proc_qpl_check_for_any_eob: qpl_decomp_end_proc = 5;
#[doc = " Stop condition: none; Check condition: b_final EOB"]
pub const qpl_decomp_end_proc_qpl_check_for_bfinal_eob: qpl_decomp_end_proc = 6;
#[doc = " Stop condition: disabled; Check condition: not last block"]
pub const qpl_decomp_end_proc_qpl_check_on_nonlast_block: qpl_decomp_end_proc = 8;
#[doc = " @brief Determines under what conditions the @ref qpl_op_decompress operation stops, and what expectations\n        there are for how the stream should end.\n @note  Specified stop condition is ignored if @ref QPL_FLAG_LAST flag is not set.\n @note  Specified check condition is performed if @ref QPL_FLAG_LAST flag is set.\n"]
pub type qpl_decomp_end_proc = ::std::os::raw::c_uint;
#[doc = "< The fastest compression with low compression ratio"]
pub const qpl_compression_levels_qpl_level_1: qpl_compression_levels = 1;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_2: qpl_compression_levels = 2;
#[doc = "< Medium compression speed, medium compression ratio"]
pub const qpl_compression_levels_qpl_level_3: qpl_compression_levels = 3;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_4: qpl_compression_levels = 4;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_5: qpl_compression_levels = 5;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_6: qpl_compression_levels = 6;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_7: qpl_compression_levels = 7;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_8: qpl_compression_levels = 8;
#[doc = "< Not supported"]
pub const qpl_compression_levels_qpl_level_9: qpl_compression_levels = 9;
pub const qpl_compression_levels_qpl_default_level: qpl_compression_levels = 1;
#[doc = "< The level with highest compression level from supported by Intel QPL"]
pub const qpl_compression_levels_qpl_high_level: qpl_compression_levels = 3;
#[doc = " @brief Enumerates different compressions levels"]
pub type qpl_compression_levels = ::std::os::raw::c_uint;
pub const qpl_status_QPL_STS_OK: qpl_status = 0;
pub const qpl_status_QPL_STS_BEING_PROCESSED: qpl_status = 1;
pub const qpl_status_QPL_STS_MORE_OUTPUT_NEEDED: qpl_status = 2;
pub const qpl_status_QPL_STS_MORE_INPUT_NEEDED: qpl_status = 3;
pub const qpl_status_QPL_STS_JOB_NOT_CONTINUABLE_ERR: qpl_status = 4;
pub const qpl_status_QPL_STS_QUEUES_ARE_BUSY_ERR: qpl_status = 5;
pub const qpl_status_QPL_STS_LIBRARY_INTERNAL_ERR: qpl_status = 6;
pub const qpl_status_QPL_STS_JOB_NOT_SUBMITTED: qpl_status = 7;
pub const qpl_status_QPL_STS_NOT_SUPPORTED_BY_WQ: qpl_status = 8;
pub const qpl_status_QPL_STS_NULL_PTR_ERR: qpl_status = 50;
pub const qpl_status_QPL_STS_OPERATION_ERR: qpl_status = 51;
pub const qpl_status_QPL_STS_NOT_SUPPORTED_MODE_ERR: qpl_status = 52;
pub const qpl_status_QPL_STS_BAD_JOB_STRUCT_ERR: qpl_status = 53;
pub const qpl_status_QPL_STS_PATH_ERR: qpl_status = 54;
pub const qpl_status_QPL_STS_INVALID_PARAM_ERR: qpl_status = 55;
pub const qpl_status_QPL_STS_FLAG_CONFLICT_ERR: qpl_status = 56;
pub const qpl_status_QPL_STS_SIZE_ERR: qpl_status = 57;
pub const qpl_status_QPL_STS_BUFFER_TOO_LARGE_ERR: qpl_status = 58;
pub const qpl_status_QPL_STS_BUFFER_OVERLAP_ERR: qpl_status = 59;
pub const qpl_status_QPL_STS_CRC64_BAD_POLYNOM: qpl_status = 60;
pub const qpl_status_QPL_STS_SET_TOO_LARGE_ERR: qpl_status = 70;
pub const qpl_status_QPL_STS_PARSER_ERR: qpl_status = 71;
pub const qpl_status_QPL_STS_OUT_FORMAT_ERR: qpl_status = 72;
pub const qpl_status_QPL_STS_DROP_BITS_OVERFLOW_ERR: qpl_status = 73;
pub const qpl_status_QPL_STS_BIT_WIDTH_OUT_EXTENDED_ERR: qpl_status = 74;
pub const qpl_status_QPL_STS_DROP_BYTES_ERR: qpl_status = 75;
pub const qpl_status_QPL_STS_MISSING_HUFFMAN_TABLE_ERR: qpl_status = 80;
pub const qpl_status_QPL_STS_INVALID_HUFFMAN_TABLE_ERR: qpl_status = 81;
pub const qpl_status_QPL_STS_MISSING_INDEX_TABLE_ERR: qpl_status = 82;
pub const qpl_status_QPL_STS_INVALID_COMPRESS_STYLE_ERR: qpl_status = 83;
pub const qpl_status_QPL_STS_INFLATE_NEED_DICT_ERR: qpl_status = 84;
pub const qpl_status_QPL_STS_INVALID_DECOMP_END_PROC_ERR: qpl_status = 85;
pub const qpl_status_QPL_STS_INVALID_BLOCK_SIZE_ERR: qpl_status = 86;
pub const qpl_status_QPL_STS_UNSUPPORTED_COMPRESSION_LEVEL: qpl_status = 87;
pub const qpl_status_QPL_STS_HUFFMAN_TABLE_TYPE_ERROR: qpl_status = 88;
pub const qpl_status_QPL_STS_SERIALIZATION_FORMAT_ERROR: qpl_status = 90;
pub const qpl_status_QPL_STS_SERIALIZATION_CORRUPTED_DUMP: qpl_status = 91;
pub const qpl_status_QPL_STS_HUFFMAN_BE_IGNORE_MORE_THAN_7_BITS_ERR: qpl_status = 95;
pub const qpl_status_QPL_STS_HUFFMAN_BE_ODD_INPUT_SIZE_ERR: qpl_status = 96;
pub const qpl_status_QPL_STS_INVALID_DEFLATE_DATA_ERR: qpl_status = 100;
pub const qpl_status_QPL_STS_NO_MEM_ERR: qpl_status = 101;
pub const qpl_status_QPL_STS_INDEX_ARRAY_TOO_SMALL: qpl_status = 102;
pub const qpl_status_QPL_STS_INDEX_GENERATION_ERR: qpl_status = 103;
pub const qpl_status_QPL_STS_ARCHIVE_HEADER_ERR: qpl_status = 104;
pub const qpl_status_QPL_STS_ARCHIVE_UNSUP_METHOD_ERR: qpl_status = 105;
pub const qpl_status_QPL_STS_OBJECT_ALLOCATION_ERR: qpl_status = 106;
pub const qpl_status_QPL_STS_BIG_HEADER_ERR: qpl_status = 201;
pub const qpl_status_QPL_STS_UNDEF_CL_CODE_ERR: qpl_status = 202;
pub const qpl_status_QPL_STS_FIRST_LL_CODE_16_ERR: qpl_status = 203;
pub const qpl_status_QPL_STS_FIRST_D_CODE_16_ERR: qpl_status = 204;
pub const qpl_status_QPL_STS_NO_LL_CODE_ERR: qpl_status = 205;
pub const qpl_status_QPL_STS_WRONG_NUM_LL_CODES_ERR: qpl_status = 206;
pub const qpl_status_QPL_STS_WRONG_NUM_DIST_CODES_ERR: qpl_status = 207;
pub const qpl_status_QPL_STS_BAD_CL_CODE_LEN_ERR: qpl_status = 208;
pub const qpl_status_QPL_STS_BAD_LL_CODE_LEN_ERR: qpl_status = 209;
pub const qpl_status_QPL_STS_BAD_DIST_CODE_LEN_ERR: qpl_status = 210;
pub const qpl_status_QPL_STS_BAD_LL_CODE_ERR: qpl_status = 211;
pub const qpl_status_QPL_STS_BAD_D_CODE_ERR: qpl_status = 212;
pub const qpl_status_QPL_STS_INVALID_BLOCK_TYPE: qpl_status = 213;
pub const qpl_status_QPL_STS_INVALID_STORED_LEN_ERR: qpl_status = 214;
pub const qpl_status_QPL_STS_BAD_EOF_ERR: qpl_status = 215;
pub const qpl_status_QPL_STS_BAD_LEN_ERR: qpl_status = 216;
pub const qpl_status_QPL_STS_BAD_DIST_ERR: qpl_status = 217;
pub const qpl_status_QPL_STS_REF_BEFORE_START_ERR: qpl_status = 218;
pub const qpl_status_QPL_STS_TIMEOUT_ERR: qpl_status = 219;
pub const qpl_status_QPL_STS_PRLE_FORMAT_ERR: qpl_status = 220;
pub const qpl_status_QPL_STS_OUTPUT_OVERFLOW_ERR: qpl_status = 221;
pub const qpl_status_QPL_STS_INTL_AECS_ERR: qpl_status = 222;
pub const qpl_status_QPL_STS_SRC1_TOO_SMALL_ERR: qpl_status = 223;
pub const qpl_status_QPL_STS_SRC2_IS_SHORT_ERR: qpl_status = 224;
pub const qpl_status_QPL_STS_DST_IS_SHORT_ERR: qpl_status = 225;
pub const qpl_status_QPL_STS_INTL_DIST_SPANS_MINI_BLOCKS: qpl_status = 226;
pub const qpl_status_QPL_STS_INTL_LEN_SPANS_MINI_BLOCKS: qpl_status = 227;
pub const qpl_status_QPL_STS_INTL_VERIF_INVALID_BLOCK_SIZE: qpl_status = 228;
pub const qpl_status_QPL_STS_INTL_VERIFY_ERR: qpl_status = 229;
pub const qpl_status_QPL_STS_INVALID_HUFFCODE_ERR: qpl_status = 230;
pub const qpl_status_QPL_STS_BIT_WIDTH_ERR: qpl_status = 231;
pub const qpl_status_QPL_STS_SRC_IS_SHORT_ERR: qpl_status = 232;
pub const qpl_status_QPL_STS_INTL_INVALID_COUNT: qpl_status = 233;
pub const qpl_status_QPL_STS_TOO_MANY_LL_CODES_ERR: qpl_status = 235;
pub const qpl_status_QPL_STS_TOO_MANY_D_CODES_ERR: qpl_status = 236;
pub const qpl_status_QPL_STS_INTL_INPROG: qpl_status = 300;
pub const qpl_status_QPL_STS_INTL_SUCCESS: qpl_status = 301;
pub const qpl_status_QPL_STS_INTL_PAGE_FAULT: qpl_status = 303;
pub const qpl_status_QPL_STS_INTL_INVALID_PAGE_REQ: qpl_status = 304;
pub const qpl_status_QPL_STS_INTL_ANALYTIC_ERROR: qpl_status = 310;
pub const qpl_status_QPL_STS_INTL_OUTPUT_OVERFLOW: qpl_status = 311;
pub const qpl_status_QPL_STS_INTL_UNSUPPORTED_OPCODE: qpl_status = 316;
pub const qpl_status_QPL_STS_INTL_INVALID_OP_FLAG: qpl_status = 317;
pub const qpl_status_QPL_STS_INTL_NONZERO_RESERVED_FIELD: qpl_status = 318;
pub const qpl_status_QPL_STS_TRANSFER_SIZE_INVALID: qpl_status = 319;
pub const qpl_status_QPL_STS_INTL_OVERLAPPING_BUFFERS: qpl_status = 322;
pub const qpl_status_QPL_STS_INTL_INVALID_COMP_HANDLE: qpl_status = 325;
pub const qpl_status_QPL_STS_INTL_TRANSLATION_PAGE_FAULT: qpl_status = 326;
pub const qpl_status_QPL_STS_INTL_COMPL_RECORD_UNALIGN: qpl_status = 327;
pub const qpl_status_QPL_STS_INTL_MISALIGNED_ADDRESS: qpl_status = 328;
pub const qpl_status_QPL_STS_INTL_PRIVILIGE_ERROR: qpl_status = 329;
pub const qpl_status_QPL_STS_INTL_TRAFFIC_CLASS_ERROR: qpl_status = 330;
pub const qpl_status_QPL_STS_INTL_DRAIN_PAGE_FAULT: qpl_status = 331;
pub const qpl_status_QPL_STS_INTL_INVALID_UR_CA_RESPONSE: qpl_status = 332;
pub const qpl_status_QPL_STS_INTL_READBACK_TIMEOUT: qpl_status = 333;
pub const qpl_status_QPL_STS_INTL_HARDWARE_TIMEOUT: qpl_status = 334;
pub const qpl_status_QPL_STS_INTL_PAGE_REQUEST_TIMEOUT: qpl_status = 335;
pub const qpl_status_QPL_STS_INTL_WATCHDOG_TIMER_EXPIRE: qpl_status = 336;
pub const qpl_status_QPL_STS_INTL_PASID_ERROR: qpl_status = 340;
pub const qpl_status_QPL_STS_INTL_INVALID_IDPTE_HANDLE: qpl_status = 341;
pub const qpl_status_QPL_STS_INTL_IDTPE_PERMISSION_ERROR: qpl_status = 342;
pub const qpl_status_QPL_STS_INTL_ID_WINDOW_ERROR: qpl_status = 343;
pub const qpl_status_QPL_STS_INTL_UPDATE_INVALID_IDPTE: qpl_status = 344;
pub const qpl_status_QPL_STS_INTL_INVALID_WINDOW_CONTROL: qpl_status = 345;
pub const qpl_status_QPL_STS_INTL_INACCESSIBLE_DOMAIN: qpl_status = 346;
pub const qpl_status_QPL_STS_INTL_INVALID_DECOMP_FLAG: qpl_status = 348;
pub const qpl_status_QPL_STS_INTL_INVALID_FILTER_FLAG: qpl_status = 349;
pub const qpl_status_QPL_STS_INTL_INVALID_INPUT_SIZE: qpl_status = 350;
pub const qpl_status_QPL_STS_INVALID_NUM_ELEM: qpl_status = 351;
pub const qpl_status_QPL_STS_INVALID_SRC1_WIDTH: qpl_status = 352;
pub const qpl_status_QPL_STS_INV_OUTPUT: qpl_status = 353;
pub const qpl_status_QPL_STS_INTL_W_PAGE_FAULT: qpl_status = 431;
pub const qpl_status_QPL_STS_INTL_W_INVALID_PAGE_REQ: qpl_status = 432;
pub const qpl_status_QPL_STS_INTL_W_TRANSLATION_PF: qpl_status = 454;
pub const qpl_status_QPL_STS_INIT_HW_NOT_SUPPORTED: qpl_status = 500;
pub const qpl_status_QPL_STS_INIT_LIBACCEL_NOT_FOUND: qpl_status = 501;
pub const qpl_status_QPL_STS_INIT_LIBACCEL_ERROR: qpl_status = 502;
pub const qpl_status_QPL_STS_INIT_WORK_QUEUES_NOT_AVAILABLE: qpl_status = 503;
pub type qpl_status = ::std::os::raw::c_uint;
#[doc = " @brief Structure for indices representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_index {
    #[doc = "< Starting bit of mini-block"]
    pub bit_offset: u32,
    #[doc = "< Cumulative calculated CRC"]
    pub crc: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_index"][::std::mem::size_of::<qpl_index>() - 8usize];
    ["Alignment of qpl_index"][::std::mem::align_of::<qpl_index>() - 4usize];
    ["Offset of field: qpl_index::bit_offset"]
        [::std::mem::offset_of!(qpl_index, bit_offset) - 0usize];
    ["Offset of field: qpl_index::crc"][::std::mem::offset_of!(qpl_index, crc) - 4usize];
};
#[doc = " @brief Structure for indices table representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_index_table {
    #[doc = "< Number of deflate blocks in the table"]
    pub block_count: u32,
    #[doc = "< Number of mini-blocks in the table"]
    pub mini_block_count: u32,
    #[doc = "< Number of mini-blocks in one deflate block"]
    pub mini_blocks_per_block: u32,
    #[doc = "< Array with indices for mini-blocks"]
    pub indices_ptr: *mut qpl_index,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_index_table"][::std::mem::size_of::<qpl_index_table>() - 24usize];
    ["Alignment of qpl_index_table"][::std::mem::align_of::<qpl_index_table>() - 8usize];
    ["Offset of field: qpl_index_table::block_count"]
        [::std::mem::offset_of!(qpl_index_table, block_count) - 0usize];
    ["Offset of field: qpl_index_table::mini_block_count"]
        [::std::mem::offset_of!(qpl_index_table, mini_block_count) - 4usize];
    ["Offset of field: qpl_index_table::mini_blocks_per_block"]
        [::std::mem::offset_of!(qpl_index_table, mini_blocks_per_block) - 8usize];
    ["Offset of field: qpl_index_table::indices_ptr"]
        [::std::mem::offset_of!(qpl_index_table, indices_ptr) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Gets the number of bytes required for indexing table\n\n @param mini_block_count      Number of mini-blocks in the table\n @param mini_blocks_per_block Number of mini-blocks in one deflate block\n @param size_ptr              The resulted number of bytes\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_NULL_PTR_ERR."]
    pub fn qpl_get_index_table_size(
        mini_block_count: u32,
        mini_blocks_per_block: u32,
        size_ptr: *mut usize,
    ) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Sets source pointer to required position for further mini-block decompression\n\n @param start_bit             Starting bit in the stream\n @param last_bit              Final bit in the stream\n @param source_pptr           Source pointer to modify\n @param first_bit_offset_ptr  Is set to the first meaningful bit in the byte\n @param last_bit_offset_ptr   Is set to the last meaningful bit in the byte\n @param compressed_size_ptr   Is set to the number of bytes used to keep the mini-block compressed\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_NULL_PTR_ERR."]
    pub fn qpl_set_mini_block_location(
        start_bit: u32,
        last_bit: u32,
        source_pptr: *mut *mut u8,
        first_bit_offset_ptr: *mut u32,
        last_bit_offset_ptr: *mut u32,
        compressed_size_ptr: *mut u32,
    ) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Sets appropriate deflate block index\n\n @param table_ptr         Pointer to the table with indices\n @param mini_block_number Index of mini-block that should be decompressed\n @param block_index_ptr   Is set to an appropriate deflate block index\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_NULL_PTR_ERR."]
    pub fn qpl_find_header_block_index(
        table_ptr: *mut qpl_index_table,
        mini_block_number: u32,
        block_index_ptr: *mut u32,
    ) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Sets appropriate mini-block index\n\n @param table_ptr         Pointer to the table with indices\n @param mini_block_number Index of mini-block that should be decompressed\n @param block_index_ptr   Is set to an appropriate mini-block index\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_NULL_PTR_ERR."]
    pub fn qpl_find_mini_block_index(
        table_ptr: *mut qpl_index_table,
        mini_block_number: u32,
        block_index_ptr: *mut u32,
    ) -> qpl_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_dictionary {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn qpl_get_dictionary_size(
        sw_level: sw_compression_level,
        hw_level: hw_compression_level,
        raw_dict_size: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn qpl_get_existing_dict_size(
        dict_ptr: *mut qpl_dictionary,
        destination: *mut usize,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_build_dictionary(
        dict_ptr: *mut qpl_dictionary,
        sw_level: sw_compression_level,
        hw_level: hw_compression_level,
        raw_dict_ptr: *const u8,
        raw_dict_size: usize,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_set_dictionary_id(
        dictionary_ptr: *mut qpl_dictionary,
        dictionary_id: u32,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_get_dictionary_id(
        dictionary_ptr: *mut qpl_dictionary,
        destination: *mut u32,
    ) -> qpl_status;
}
pub const qpl_serialization_format_e_serialization_compact: qpl_serialization_format_e =
    0;
pub const qpl_serialization_format_e_serialization_raw: qpl_serialization_format_e = 1;
pub type qpl_serialization_format_e = ::std::os::raw::c_uint;
pub type serialization_flags_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serialization_options_t {
    pub format: qpl_serialization_format_e,
    pub flags: serialization_flags_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of serialization_options_t"]
        [::std::mem::size_of::<serialization_options_t>() - 16usize];
    ["Alignment of serialization_options_t"]
        [::std::mem::align_of::<serialization_options_t>() - 8usize];
    ["Offset of field: serialization_options_t::format"]
        [::std::mem::offset_of!(serialization_options_t, format) - 0usize];
    ["Offset of field: serialization_options_t::flags"]
        [::std::mem::offset_of!(serialization_options_t, flags) - 8usize];
};
pub const qpl_statistics_mode_qpl_compression_mode: qpl_statistics_mode = 0;
pub const qpl_statistics_mode_qpl_gathering_mode: qpl_statistics_mode = 1;
pub type qpl_statistics_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_histogram {
    pub literal_lengths: [u32; 286usize],
    pub reserved_literal_lengths: [u32; 2usize],
    pub distances: [u32; 30usize],
    pub reserved_distances: [u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_histogram"][::std::mem::size_of::<qpl_histogram>() - 1280usize];
    ["Alignment of qpl_histogram"][::std::mem::align_of::<qpl_histogram>() - 4usize];
    ["Offset of field: qpl_histogram::literal_lengths"]
        [::std::mem::offset_of!(qpl_histogram, literal_lengths) - 0usize];
    ["Offset of field: qpl_histogram::reserved_literal_lengths"]
        [::std::mem::offset_of!(qpl_histogram, reserved_literal_lengths) - 1144usize];
    ["Offset of field: qpl_histogram::distances"]
        [::std::mem::offset_of!(qpl_histogram, distances) - 1152usize];
    ["Offset of field: qpl_histogram::reserved_distances"]
        [::std::mem::offset_of!(qpl_histogram, reserved_distances) - 1272usize];
};
unsafe extern "C" {
    pub fn qpl_gather_deflate_statistics(
        source_ptr: *mut u8,
        source_length: u32,
        histogram_ptr: *mut qpl_histogram,
        level: qpl_compression_levels,
        path: qpl_path_t,
    ) -> qpl_status;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_huffman_triplet {
    pub value: u8,
    pub code_length: u8,
    pub code: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_huffman_triplet"]
        [::std::mem::size_of::<qpl_huffman_triplet>() - 4usize];
    ["Alignment of qpl_huffman_triplet"]
        [::std::mem::align_of::<qpl_huffman_triplet>() - 2usize];
    ["Offset of field: qpl_huffman_triplet::value"]
        [::std::mem::offset_of!(qpl_huffman_triplet, value) - 0usize];
    ["Offset of field: qpl_huffman_triplet::code_length"]
        [::std::mem::offset_of!(qpl_huffman_triplet, code_length) - 1usize];
    ["Offset of field: qpl_huffman_triplet::code"]
        [::std::mem::offset_of!(qpl_huffman_triplet, code) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_huffman_table {
    _unused: [u8; 0],
}
pub type qpl_huffman_table_t = *mut qpl_huffman_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct allocator_t {
    pub allocator: ::std::option::Option<
        unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
    >,
    pub deallocator:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of allocator_t"][::std::mem::size_of::<allocator_t>() - 16usize];
    ["Alignment of allocator_t"][::std::mem::align_of::<allocator_t>() - 8usize];
    ["Offset of field: allocator_t::allocator"]
        [::std::mem::offset_of!(allocator_t, allocator) - 0usize];
    ["Offset of field: allocator_t::deallocator"]
        [::std::mem::offset_of!(allocator_t, deallocator) - 8usize];
};
pub const qpl_huffman_table_type_e_combined_table_type: qpl_huffman_table_type_e = 0;
pub const qpl_huffman_table_type_e_compression_table_type: qpl_huffman_table_type_e = 1;
pub const qpl_huffman_table_type_e_decompression_table_type: qpl_huffman_table_type_e = 2;
pub type qpl_huffman_table_type_e = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qpl_deflate_huffman_table_create(
        type_: qpl_huffman_table_type_e,
        path: qpl_path_t,
        allocator: allocator_t,
        table_ptr: *mut qpl_huffman_table_t,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_only_table_create(
        type_: qpl_huffman_table_type_e,
        path: qpl_path_t,
        allocator: allocator_t,
        table_ptr: *mut qpl_huffman_table_t,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_destroy(table: qpl_huffman_table_t) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_init_with_histogram(
        table: qpl_huffman_table_t,
        histogram_ptr: *const qpl_histogram,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_init_with_triplets(
        table: qpl_huffman_table_t,
        triplet_ptr: *const qpl_huffman_triplet,
        triplet_count: u32,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_init_with_other(
        table: qpl_huffman_table_t,
        other: qpl_huffman_table_t,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_get_type(
        table: qpl_huffman_table_t,
        type_ptr: *mut qpl_huffman_table_type_e,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_get_serialized_size(
        table: qpl_huffman_table_t,
        options: serialization_options_t,
        size_ptr: *mut usize,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_serialize(
        table: qpl_huffman_table_t,
        dump_buffer_ptr: *mut u8,
        dump_buffer_size: usize,
        options: serialization_options_t,
    ) -> qpl_status;
}
unsafe extern "C" {
    pub fn qpl_huffman_table_deserialize(
        dump_buffer_ptr: *const u8,
        dump_buffer_size: usize,
        allocator: allocator_t,
        table_ptr: *mut qpl_huffman_table_t,
    ) -> qpl_status;
}
#[doc = " @brief @ref qpl_job extension that holds internal buffers and context for @ref qpl_operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_aux_data {
    #[doc = "< @ref qpl_op_compress operation state"]
    pub compress_state_ptr: *mut u8,
    #[doc = "< @ref qpl_op_decompress operation state"]
    pub decompress_state_ptr: *mut u8,
    #[doc = "< Analytics @ref qpl_operation buffers"]
    pub analytics_state_ptr: *mut u8,
    #[doc = "< Internal middle-level layer buffer"]
    pub middle_layer_buffer_ptr: *mut u8,
    #[doc = "< Hardware path execution context"]
    pub hw_state_ptr: *mut u8,
    #[doc = "< @ref qpl_path_t marker"]
    pub path: qpl_path_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_aux_data"][::std::mem::size_of::<qpl_aux_data>() - 48usize];
    ["Alignment of qpl_aux_data"][::std::mem::align_of::<qpl_aux_data>() - 8usize];
    ["Offset of field: qpl_aux_data::compress_state_ptr"]
        [::std::mem::offset_of!(qpl_aux_data, compress_state_ptr) - 0usize];
    ["Offset of field: qpl_aux_data::decompress_state_ptr"]
        [::std::mem::offset_of!(qpl_aux_data, decompress_state_ptr) - 8usize];
    ["Offset of field: qpl_aux_data::analytics_state_ptr"]
        [::std::mem::offset_of!(qpl_aux_data, analytics_state_ptr) - 16usize];
    ["Offset of field: qpl_aux_data::middle_layer_buffer_ptr"]
        [::std::mem::offset_of!(qpl_aux_data, middle_layer_buffer_ptr) - 24usize];
    ["Offset of field: qpl_aux_data::hw_state_ptr"]
        [::std::mem::offset_of!(qpl_aux_data, hw_state_ptr) - 32usize];
    ["Offset of field: qpl_aux_data::path"]
        [::std::mem::offset_of!(qpl_aux_data, path) - 40usize];
};
#[doc = " @brief @ref qpl_job extension that holds internal buffers and context for @ref qpl_operation"]
pub type qpl_data = qpl_aux_data;
#[doc = " @brief Defines the general Intel QPL JOB API structure to perform task configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qpl_job {
    #[doc = "< Next input byte"]
    pub next_in_ptr: *mut u8,
    #[doc = "< Number of bytes available at next_in_ptr"]
    pub available_in: u32,
    #[doc = "< Total number of bytes read so far"]
    pub total_in: u32,
    #[doc = "< Next output byte"]
    pub next_out_ptr: *mut u8,
    #[doc = "< Number of bytes available at next_out_ptr"]
    pub available_out: u32,
    #[doc = "< Total number of bytes written so far"]
    pub total_out: u32,
    #[doc = "< Intel QPL operation"]
    pub op: qpl_operation,
    #[doc = "< Auxiliary operation flags, see QPL_FLAGS in qpl/c_api/defs.h"]
    pub flags: u32,
    #[doc = "< CRC - Input and Output"]
    pub crc: u32,
    #[doc = "< Simple XOR check sum"]
    pub xor_checksum: u32,
    #[doc = "< Actual bits in the last written byte (or word for BE16 format)"]
    pub last_bit_offset: u32,
    #[doc = "< Compression level - default or high"]
    pub level: qpl_compression_levels,
    #[doc = "< Represents mode in which deflate should be performed"]
    pub statistics_mode: qpl_statistics_mode,
    #[doc = "< Huffman table for compression"]
    pub huffman_table: qpl_huffman_table_t,
    #[doc = "< The dictionary used for compression / decompression"]
    pub dictionary: *mut qpl_dictionary,
    #[doc = "< Index block (mini-block) size"]
    pub mini_block_size: qpl_mini_block_size,
    #[doc = "< Index array address"]
    pub idx_array: *mut u64,
    #[doc = "< Size of index array"]
    pub idx_max_size: u32,
    #[doc = "< Number of generated indexes"]
    pub idx_num_written: u32,
    #[doc = "< Value is qpl_decomp_end_proc"]
    pub decomp_end_processing: u8,
    #[doc = "< 0-7 (or 0-15 for BE16 format) - a number of bits to skip at the start of the 1st byte (or word for BE16 format)"]
    pub ignore_start_bits: u8,
    #[doc = "< 0-7 (or 0-15 for BE16 format) - a number of bits to skip at the end of the last byte (or word for BE16 format)"]
    pub ignore_end_bits: u8,
    #[doc = "< Polynomial used for the crc64 operation"]
    pub crc64_poly: u64,
    #[doc = "< Initial and final CRC value for the crc64 operation"]
    pub crc64: u64,
    #[doc = "< Pointer to source-2 data. Updated value is returned"]
    pub next_src2_ptr: *mut u8,
    #[doc = "< Number of valid bytes of source-2 data"]
    pub available_src2: u32,
    #[doc = "< Source-1 bit width for Analytics. Valid values are 1-32"]
    pub src1_bit_width: u32,
    #[doc = "< Source-2 bit width for Analytics. Valid values are 1-32"]
    pub src2_bit_width: u32,
    #[doc = "< Number of input elements for Analytics"]
    pub num_input_elements: u32,
    #[doc = " Output bit width enumeration. Valid values are nominal, 8-, 16-, or 32-bits"]
    pub out_bit_width: qpl_out_format,
    #[doc = " Low parameter for operations extract or scan"]
    pub param_low: u32,
    #[doc = " High parameter for operations extract or scan"]
    pub param_high: u32,
    #[doc = " Number of initial bytes to be dropped at the start of the Analytics portion of the pipeline"]
    pub drop_initial_bytes: u32,
    #[doc = " The index of initial output element from Analytics. This affects modified bit-vector output\n and the bit-vector aggregate values"]
    pub initial_output_index: u32,
    #[doc = " Enumeration of what parser to use to parse Analytics source-1 data"]
    pub parser: qpl_parser,
    #[doc = "< Output aggregate value - index of the first min value"]
    pub first_index_min_value: u32,
    #[doc = "< Output aggregate value - index of the last max value"]
    pub last_index_max_value: u32,
    #[doc = "< Output aggregate value - sum of all values"]
    pub sum_value: u32,
    #[doc = "< ID of the NUMA. Set it to -1 for auto detecting"]
    pub numa_id: i32,
    #[doc = "< Internal memory buffers & structures for all Intel QPL operations"]
    pub data_ptr: qpl_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qpl_job"][::std::mem::size_of::<qpl_job>() - 240usize];
    ["Alignment of qpl_job"][::std::mem::align_of::<qpl_job>() - 8usize];
    ["Offset of field: qpl_job::next_in_ptr"]
        [::std::mem::offset_of!(qpl_job, next_in_ptr) - 0usize];
    ["Offset of field: qpl_job::available_in"]
        [::std::mem::offset_of!(qpl_job, available_in) - 8usize];
    ["Offset of field: qpl_job::total_in"]
        [::std::mem::offset_of!(qpl_job, total_in) - 12usize];
    ["Offset of field: qpl_job::next_out_ptr"]
        [::std::mem::offset_of!(qpl_job, next_out_ptr) - 16usize];
    ["Offset of field: qpl_job::available_out"]
        [::std::mem::offset_of!(qpl_job, available_out) - 24usize];
    ["Offset of field: qpl_job::total_out"]
        [::std::mem::offset_of!(qpl_job, total_out) - 28usize];
    ["Offset of field: qpl_job::op"][::std::mem::offset_of!(qpl_job, op) - 32usize];
    ["Offset of field: qpl_job::flags"][::std::mem::offset_of!(qpl_job, flags) - 36usize];
    ["Offset of field: qpl_job::crc"][::std::mem::offset_of!(qpl_job, crc) - 40usize];
    ["Offset of field: qpl_job::xor_checksum"]
        [::std::mem::offset_of!(qpl_job, xor_checksum) - 44usize];
    ["Offset of field: qpl_job::last_bit_offset"]
        [::std::mem::offset_of!(qpl_job, last_bit_offset) - 48usize];
    ["Offset of field: qpl_job::level"][::std::mem::offset_of!(qpl_job, level) - 52usize];
    ["Offset of field: qpl_job::statistics_mode"]
        [::std::mem::offset_of!(qpl_job, statistics_mode) - 56usize];
    ["Offset of field: qpl_job::huffman_table"]
        [::std::mem::offset_of!(qpl_job, huffman_table) - 64usize];
    ["Offset of field: qpl_job::dictionary"]
        [::std::mem::offset_of!(qpl_job, dictionary) - 72usize];
    ["Offset of field: qpl_job::mini_block_size"]
        [::std::mem::offset_of!(qpl_job, mini_block_size) - 80usize];
    ["Offset of field: qpl_job::idx_array"]
        [::std::mem::offset_of!(qpl_job, idx_array) - 88usize];
    ["Offset of field: qpl_job::idx_max_size"]
        [::std::mem::offset_of!(qpl_job, idx_max_size) - 96usize];
    ["Offset of field: qpl_job::idx_num_written"]
        [::std::mem::offset_of!(qpl_job, idx_num_written) - 100usize];
    ["Offset of field: qpl_job::decomp_end_processing"]
        [::std::mem::offset_of!(qpl_job, decomp_end_processing) - 104usize];
    ["Offset of field: qpl_job::ignore_start_bits"]
        [::std::mem::offset_of!(qpl_job, ignore_start_bits) - 105usize];
    ["Offset of field: qpl_job::ignore_end_bits"]
        [::std::mem::offset_of!(qpl_job, ignore_end_bits) - 106usize];
    ["Offset of field: qpl_job::crc64_poly"]
        [::std::mem::offset_of!(qpl_job, crc64_poly) - 112usize];
    ["Offset of field: qpl_job::crc64"]
        [::std::mem::offset_of!(qpl_job, crc64) - 120usize];
    ["Offset of field: qpl_job::next_src2_ptr"]
        [::std::mem::offset_of!(qpl_job, next_src2_ptr) - 128usize];
    ["Offset of field: qpl_job::available_src2"]
        [::std::mem::offset_of!(qpl_job, available_src2) - 136usize];
    ["Offset of field: qpl_job::src1_bit_width"]
        [::std::mem::offset_of!(qpl_job, src1_bit_width) - 140usize];
    ["Offset of field: qpl_job::src2_bit_width"]
        [::std::mem::offset_of!(qpl_job, src2_bit_width) - 144usize];
    ["Offset of field: qpl_job::num_input_elements"]
        [::std::mem::offset_of!(qpl_job, num_input_elements) - 148usize];
    ["Offset of field: qpl_job::out_bit_width"]
        [::std::mem::offset_of!(qpl_job, out_bit_width) - 152usize];
    ["Offset of field: qpl_job::param_low"]
        [::std::mem::offset_of!(qpl_job, param_low) - 156usize];
    ["Offset of field: qpl_job::param_high"]
        [::std::mem::offset_of!(qpl_job, param_high) - 160usize];
    ["Offset of field: qpl_job::drop_initial_bytes"]
        [::std::mem::offset_of!(qpl_job, drop_initial_bytes) - 164usize];
    ["Offset of field: qpl_job::initial_output_index"]
        [::std::mem::offset_of!(qpl_job, initial_output_index) - 168usize];
    ["Offset of field: qpl_job::parser"]
        [::std::mem::offset_of!(qpl_job, parser) - 172usize];
    ["Offset of field: qpl_job::first_index_min_value"]
        [::std::mem::offset_of!(qpl_job, first_index_min_value) - 176usize];
    ["Offset of field: qpl_job::last_index_max_value"]
        [::std::mem::offset_of!(qpl_job, last_index_max_value) - 180usize];
    ["Offset of field: qpl_job::sum_value"]
        [::std::mem::offset_of!(qpl_job, sum_value) - 184usize];
    ["Offset of field: qpl_job::numa_id"]
        [::std::mem::offset_of!(qpl_job, numa_id) - 188usize];
    ["Offset of field: qpl_job::data_ptr"]
        [::std::mem::offset_of!(qpl_job, data_ptr) - 192usize];
};
unsafe extern "C" {
    #[doc = " @brief Calculates the amount of memory, in bytes, required for the qpl_job structure.\n\n @param[in]   qpl_path      type of implementation path to use - @ref qpl_path_auto,\n                            @ref qpl_path_hardware or @ref qpl_path_software\n @param[out]  job_size_ptr  a pointer to uint32_t, where the qpl_job size (in bytes) is stored\n\n @note Some kind of dispatching is done at this stage - in absence of hardware,\n       it will require significantly more memory for internal buffers\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_PATH_ERR."]
    pub fn qpl_get_job_size(qpl_path: qpl_path_t, job_size_ptr: *mut u32) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Initializes the qpl_job structure and ensures proper alignment of internal structures.\n This API should be called only once, after a new @ref qpl_job object is allocated.\n\n @param[in]      qpl_path     type of implementation path to use - @ref qpl_path_auto,\n                              @ref qpl_path_hardware or @ref qpl_path_software\n @param[in,out]  qpl_job_ptr  a pointer to the @ref qpl_job structure\n\n @warning Memory for qpl_job structure must be allocated at the application side. Size (in bytes)\n must be obtained with the @ref qpl_get_job_size function.\n\n @note qpl_job is an alias to the @ref qpl_job structure - must contain additional internal memory buffers for\n SW path of compression/decompression/etc.\n\n @return\n     - @ref QPL_STS_OK;\n     - @ref QPL_STS_PATH_ERR;\n     - @ref QPL_STS_NULL_PTR_ERR."]
    pub fn qpl_init_job(qpl_path: qpl_path_t, qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Parses the qpl_job structure and forms the corresponding processing functions pipeline.\n\n @param[in,out]  qpl_job_ptr  Pointer to the initialized @ref qpl_job structure\n\n @return One of statuses presented in the @ref qpl_status"]
    pub fn qpl_execute_job(qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Parses the qpl_job structure and forms the corresponding processing functions pipeline.\n        In case of software solution, it is an alias for execute_job.\n\n @param[in,out]  qpl_job_ptr  Pointer to the initialized @ref qpl_job structure\n\n @return One of statuses presented in the @ref qpl_status\n"]
    pub fn qpl_submit_job(qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Waits for the end of @ref qpl_job processing. (waits until the job is completed)\n\n @param[in,out]  qpl_job_ptr  Pointer to the initialized @ref qpl_job structure\n\n @return One of statuses presented in the @ref qpl_status\n"]
    pub fn qpl_wait_job(qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Checks the status of @ref qpl_job processing. (can be queried periodically to check the status\n        of the qpl_submit_job)\n\n @param[in,out]  qpl_job_ptr  Pointer to the initialized @ref qpl_job structure\n\n @return One of statuses presented in the @ref qpl_status"]
    pub fn qpl_check_job(qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Completes @ref qpl_job lifecycle: disconnects from the internal library context, frees internal resources.\n\n @param qpl_job_ptr Pointer to the initialized @ref qpl_job structure\n\n @return ne of statuses presented in the @ref qpl_status"]
    pub fn qpl_fini_job(qpl_job_ptr: *mut qpl_job) -> qpl_status;
}
unsafe extern "C" {
    #[doc = " @brief Calculate the maximum buffer size for compression, compression output should not exceed this size.\n\n @param[in]  source_size  size of the input buffer\n\n @note This only applies to deflate compressions, Huffman Only mode is not supported.\n @note When performing compression over multiple submissions, the user must call the API for each chunk of data.\n @note This function does not include overhead for gzip/zlib headers and footers.\n\n @return uint32_t"]
    pub fn qpl_get_safe_deflate_compression_buffer_size(source_size: u32) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Returns a string with a version of the library"]
    pub fn qpl_get_library_version() -> *const ::std::os::raw::c_char;
}
